= 導入

本章では、GMPの導入と使用例を示します。
GMPを使って多倍長整数の計算がしたい！という人は本章を参考にしてください。
また、本章で想定する実行環境は、LinuxもしくはmacOSとなります。筆者の環境はUbuntu18.04です。途中でアセンブリを示すことがあり、objdumpを使用するので、追実験を行いたい方は筆者と同じUbuntu18.04の利用をおすすめします。
例示するプログラムは、特にことわりがない限りはC++です。

====[notoc] GMPのダウンロードとビルド
2021/01/24時点での最新版であるv6.2.1をダウンロードします。
configureの引数には、C++用のビルドを有効にする--enable-cxxフラグを与えます。ビルドオプションはこちら@<fn>{gmp-build-config}を参考にしてください。

//footnote[gmp-build-config][https://gmplib.org/]


macOSの場合、Homebrewを使ってGMPをビルドすることも可能なのですが、Homebrewからではなくソースコードからビルドすることをおすすめします。

//terminal[][GMPのダウンロードとビルド]{
$ wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz
$ tar -xvf gmp-6.2.1.tar.xz
$ cd gmp-6.2.1
$ ./configure --enable-cxx
$ make && make install
//}

#@#デフォルトでは/usr/local/以下にヘッダーファイルやライブラリが配置されます。

====[notoc] GMPの使用例
GMPが使用できる環境が整ったので、さっそく使ってみたいと思います。
//noindent
多倍長整数のクラスであるmpz_classの使用例を2つ示します。（有理数はmpq_class、浮動小数点数はmpf_classです。とりあえず本章ではmpz_classのみということで。）
コンパイルオプションに-lgmpxx -lgmpを渡し忘れないように注意しましょう。

//list[][GMP sample 1]{
#include <iostream>
#include <gmpxx.h>

int main() {
    mpz_class x = 1;

    for (size_t i = 1; i <= 50; i++) {
        x *= i;
    }
    std::cout << x << std::endl;
}
//}

//terminal[][GMPを使ったプログラムのビルド 1]{
$ g++ source.cpp -lgmpxx -lgmp && ./a.out
30414093201713378043612608166064768844377641568960512000000000000
//}

50の階乗を計算してみました。64ビットを超える値でも、きちんと計算できていることがわかります。プログラマはオーバーフローの可能性を考慮しなくてもいいわけです。また、四則演算も、プリミティブ型と同様に+-*/が使えます。
便利ですね。

//list[][GMP sample 2][foldmark=off]{
#include <iostream>
#include <gmpxx.h>

int main() {
    mpz_class e("65537", 10);
    mpz_class p("ecfc4ddf98ac14100230284ddf6f3a109995e7429407039985776681a702eedd25683888f090a6f87778aeed537170ef2901644a560ae76273fccc5b45aa9f97", 16);
    mpz_class q("edf5598b5a427b9c64ecd007e336e21eb3a93788b55c3f0cd137e2bbae554d35721b1fe6db65e9f0a23c3b963702ecb4fcab58882a0cdc161d1af571cf14a553", 16);
    mpz_class n = p*q;
    mpz_class c, m = 3;

    mpz_powm(c.get_mpz_t(), m.get_mpz_t(), e.get_mpz_t(), n.get_mpz_t());
    std::cout << c << std::endl;
}
//}

//terminal[][GMPを使ったプログラムのビルド 2]{
$ g++ source.cpp -lgmpxx -lgmp && ./a.out
111773376294672907599702415031428295845690629305468357913917896182471801686330009578531360571804920943059636777009094799335528568314483574904886433451806859027101217033672119248636551604562278399551494662933188699304169977202699403671712165132706561340874238875631162811971511575951469214284481779854325683361
//}

なんだかいきなりゴツくなりましたね。見た目はイカついですが、難しいことはしていません。
mpz_classはコンストラクタに文字列と基数を受け取ることができます。eは10進数で65537を、pとqは、長いので省略しますが16進数で値を受け取っています。

mpz_powmはべき剰余の関数です。mpz_classではなくmpz_tを引数に取るので、get_mpz_t()メソッドを呼び出しています。mpz_class用のべき剰余関数は実装されていないため、mpz_t用の関数を呼び出しているわけですね。

もうお気付きかもしれませんが、mpz_classというのはmpz_tのwrapperです。mpz_tに演算子を定義（実装）することで、プログラマにとって†いい感じに†書きやすくなっています。  
mpz_classは、厳密には"mpz_tの"wrapperではないのですが（2秒で嘘を吐く）、このへんは後々お話しましょう。


====[notoc] 本章のまとめ
本章では、GMPの導入とmpz_classを使ったサンプルプログラムを示しました。使うだけなら意外と簡単ですよね（ですよね？）。次章からは、GMPの実装を見ていきます。C/C++のプログラムを読んだり、自分でプログラムを書いてコンパイルしたオブジェクトファイルのアセンブリを読んだりします。乞うご期待！
